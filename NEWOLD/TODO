
int map[HEI_WALL][WID_WALL] = {
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},
    {1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1},
    {1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1},
    {1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},
    {1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1},
    {1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1},
    {1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},
    {1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1},
    {1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1},
    {1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
};



int map[HEI_WALL][WID_WALL];

void	generate_random_map(void)
{
	int y = 0;
	int x;

	while (y < HEI_WALL)
	{
		x = 0;
		while (x < WID_WALL)
		{
			// Tirage aléatoire : 20% de murs (1), 80% de vide (0)
			if (rand() % 5 == 0)
				map[y][x] = 1;
			else
				map[y][x] = 0;
			x++;
		}
		y++;
	}
}


CPP00

Creer une classe PhoneBook

qui contiendra une autre classe Contact (avec les attributs d'un contact)

et PhoneBook possedera un tableau Contact[8].






int map[HEI_WALL][WID_WALL];
// Directions possibles pour les mouvements (haut, bas, gauche, droite)
int dx[] = {0, 0, -1, 1};
int dy[] = {-1, 1, 0, 0};

int is_valid(int x, int y)
{
    return x >= 0 && x < WID_WALL && y >= 0 && y < HEI_WALL;
}

void dfs(int x, int y)
{
    // Mélanger les directions pour explorer de manière aléatoire
    int directions[4] = {0, 1, 2, 3};
    for (int i = 0; i < 4; i++) {
        int j = rand() % 4;
        int tmp = directions[i];
        directions[i] = directions[j];
        directions[j] = tmp;
    }

    // Explore les 4 directions possibles
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[directions[i]] * 2;  // Espacer les déplacements en augmentant la distance
        int ny = y + dy[directions[i]] * 2;  // en multipliant par 2

        // Vérifier si la nouvelle position est valide
        if (is_valid(nx, ny) && map[ny][nx] == 0) {
            // Créer un passage
            map[ny][nx] = 1;
            // Démolir un mur intermédiaire pour créer le chemin
            map[y + dy[directions[i]]][x + dx[directions[i]]] = 1;  // Corrigé : Accès à la case 2D
            // Appel récursif pour continuer l'exploration
            dfs(nx, ny);
        }
    }
}



// Initialisation de la map
void initialize_map(void)
{
    for (int y = 0; y < HEI_WALL; y++) {
        for (int x = 0; x < WID_WALL; x++) {
            map[y][x] = 0; // Remplir la map avec des murs
        }
    }

    // Définir le point de départ (par exemple, en haut à gauche)
    map[1][1] = 1; // Démarrer avec un chemin libre à partir de (1, 1)

    // Lancer DFS pour générer le labyrinthe
    dfs(1, 1);
}

















{
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
    {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1},
    {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
  };
























  int	ft_keyhook(int keysym, t_mlx_data *pdata)
{
	//printf("Touche pressée : %d\n", keysym);
	// if (keysym == XK_Up)
	// 	pdata->py -= 10;
	// else if (keysym == XK_Down)
	// 	pdata->py += 10;
	// else if (keysym == XK_Left)
	// 	pdata->px -= 10;
	// else if (keysym == XK_Right)
	// 	pdata->px += 10;
	if (keysym == XK_w)
	{
		pdata->py += pdata->dy;
		pdata->px += pdata->dx;	
	}
	else if (keysym == XK_s)
	{
		pdata->py -= pdata->dy;
		pdata->px -= pdata->dx;	
	}
	else if (keysym == XK_a)
	{
		pdata->an -= 0.5;
		if (pdata->an < 0)
			pdata->an += 2 * PI;
		pdata->dx = cos(pdata->an) * 5;
		pdata->dy = sin(pdata->an) * 5;
	}
	else if (keysym == XK_d)
	{
		pdata->an += 0.5;
		if (pdata->an > 2 * PI)
			pdata->an -= 2 * PI;
		pdata->dx = cos(pdata->an) * 5;
		pdata->dy = sin(pdata->an) * 5;
	}
	if (keysym == XK_Escape)
	{
		mlx_destroy_image(pdata->connect, pdata->img_ptr);
		ft_stop(pdata, 1, 1, NULL);
	}
	ft_show(pdata);
	return (0);
}