
int map[HEI_WALL][WID_WALL] = {
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},
    {1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1},
    {1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1},
    {1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},
    {1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1},
    {1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1},
    {1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},
    {1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1},
    {1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1},
    {1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
};



int map[HEI_WALL][WID_WALL];

void	generate_random_map(void)
{
	int y = 0;
	int x;

	while (y < HEI_WALL)
	{
		x = 0;
		while (x < WID_WALL)
		{
			// Tirage aléatoire : 20% de murs (1), 80% de vide (0)
			if (rand() % 5 == 0)
				map[y][x] = 1;
			else
				map[y][x] = 0;
			x++;
		}
		y++;
	}
}


CPP00

Creer une classe PhoneBook

qui contiendra une autre classe Contact (avec les attributs d'un contact)

et PhoneBook possedera un tableau Contact[8].






int map[HEI_WALL][WID_WALL];
// Directions possibles pour les mouvements (haut, bas, gauche, droite)
int dx[] = {0, 0, -1, 1};
int dy[] = {-1, 1, 0, 0};

int is_valid(int x, int y)
{
    return x >= 0 && x < WID_WALL && y >= 0 && y < HEI_WALL;
}

void dfs(int x, int y)
{
    // Mélanger les directions pour explorer de manière aléatoire
    int directions[4] = {0, 1, 2, 3};
    for (int i = 0; i < 4; i++) {
        int j = rand() % 4;
        int tmp = directions[i];
        directions[i] = directions[j];
        directions[j] = tmp;
    }

    // Explore les 4 directions possibles
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[directions[i]] * 2;  // Espacer les déplacements en augmentant la distance
        int ny = y + dy[directions[i]] * 2;  // en multipliant par 2

        // Vérifier si la nouvelle position est valide
        if (is_valid(nx, ny) && map[ny][nx] == 0) {
            // Créer un passage
            map[ny][nx] = 1;
            // Démolir un mur intermédiaire pour créer le chemin
            map[y + dy[directions[i]]][x + dx[directions[i]]] = 1;  // Corrigé : Accès à la case 2D
            // Appel récursif pour continuer l'exploration
            dfs(nx, ny);
        }
    }
}



// Initialisation de la map
void initialize_map(void)
{
    for (int y = 0; y < HEI_WALL; y++) {
        for (int x = 0; x < WID_WALL; x++) {
            map[y][x] = 0; // Remplir la map avec des murs
        }
    }

    // Définir le point de départ (par exemple, en haut à gauche)
    map[1][1] = 1; // Démarrer avec un chemin libre à partir de (1, 1)

    // Lancer DFS pour générer le labyrinthe
    dfs(1, 1);
}